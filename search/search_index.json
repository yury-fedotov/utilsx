{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"UtilsX","text":"Generic utilities for Python projects.          Declutter code, clarify intents, develop only the logic unique to your software.  <ul> <li> <p>\ud83d\uddc4\ufe0f Collections</p> <p>One-liners for getting duplicates, checking that all elements are equal, and more</p> <p> Master collections</p> </li> <li> <p>\ud83e\udea8 Constants</p> <p>Common numbers and unit conversion ratios: <code>MINUTES_IN_HOUR</code>, <code>BILLION</code>, and more</p> <p> Never hard-code <code>60</code> again</p> </li> <li> <p>\ud83c\udfa8 Decorators</p> <p>Function wrappers for adjusting or enhancing their operations</p> <p> Tweak third party functions</p> </li> <li> <p>\ud83d\udccb Dictionaries</p> <p>Utilities for common <code>dict</code> operations: summation, filtering, and more</p> <p> Keep your business logic clean</p> </li> <li> <p>\u26d4 Exceptions</p> <p>Utilities to help enrich exception messages</p> <p> Fail runs gracefully</p> </li> <li> <p>\u27b0 Functional</p> <p>Utilities for functional programming, like identity function</p> <p> Canonical as Haskell</p> </li> <li> <p>\ud83e\uddee Math</p> <p>Normalize sequences, check trends, avoid <code>ZeroDivisionError</code> in one line</p> <p> Reduce boilerplate in analytics</p> </li> <li> <p>\ud83d\udcdd Text</p> <p>String utilities missing in the standard library</p> <p> Become the Shakespeare</p> </li> <li> <p>\ud83c\uddf9 <code>TypeVar</code>s</p> <p>Popular type variables for your own generic functions</p> <p> You probably use <code>Any</code> wrong</p> </li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>UtilsX - a collection of generic Python utility functions and types.</p>"},{"location":"api/#utilsx.collections","title":"<code>collections</code>","text":"<p>Utilities for working with collections.</p>"},{"location":"api/#utilsx.collections.check_equal_length","title":"<code>check_equal_length(*collections)</code>","text":"<p>Given an arbitrary number of collections, check if they all have equal length.</p> <p>Parameters:</p> Name Type Description Default <code>*collections</code> <code>Sized</code> <p>Objects which have length to be checked for its equality.</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether all provided collections have equal length.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no collections provided.</p> Source code in <code>src/utilsx/collections.py</code> <pre><code>def check_equal_length(*collections: Sized) -&gt; bool:\n    \"\"\"Given an arbitrary number of collections, check if they all have equal length.\n\n    Args:\n        *collections: Objects which have length to be checked for its equality.\n\n    Returns:\n        Whether all provided collections have equal length.\n\n    Raises:\n        ValueError: If no collections provided.\n    \"\"\"\n    if not collections:\n        raise ValueError(\"No collections to provided to check for lengths equality.\")\n    benchmark_length = len(collections[0])\n    return all(len(collection) == benchmark_length for collection in collections)\n</code></pre>"},{"location":"api/#utilsx.collections.get_duplicates","title":"<code>get_duplicates(iterable)</code>","text":"<p>Get a set of all values in a collection that are duplicates, i.e., present more than once.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[T]</code> <p>A collection to check.</p> required <p>Returns:</p> Type Description <code>frozenset[T]</code> <p>A set of values that are present more than once.</p> Source code in <code>src/utilsx/collections.py</code> <pre><code>def get_duplicates(iterable: Iterable[T]) -&gt; frozenset[T]:\n    \"\"\"Get a set of all values in a collection that are duplicates, i.e., present more than once.\n\n    Args:\n        iterable: A collection to check.\n\n    Returns:\n        A set of values that are present more than once.\n    \"\"\"\n    return frozenset(key for key, value in Counter(iterable).items() if value &gt; 1)\n</code></pre>"},{"location":"api/#utilsx.collections.is_collection_of_equal_elements","title":"<code>is_collection_of_equal_elements(collection)</code>","text":"<p>Check whether all elements in a collection are equal to each other.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Collection[Any]</code> <p>A collection to check that all elements are equal.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether all elements are equal to each other.</p> Source code in <code>src/utilsx/collections.py</code> <pre><code>def is_collection_of_equal_elements(collection: Collection[Any]) -&gt; bool:\n    \"\"\"Check whether all elements in a collection are equal to each other.\n\n    Args:\n        collection: A collection to check that all elements are equal.\n\n    Returns:\n        Whether all elements are equal to each other.\n    \"\"\"\n    collection = list(collection)\n    return all(element == collection[0] for element in collection)\n</code></pre>"},{"location":"api/#utilsx.constants","title":"<code>constants</code>","text":"<p>Common constant values from math, physics, etc.</p>"},{"location":"api/#utilsx.decorators","title":"<code>decorators</code>","text":"<p>Profiling pipeline nodes.</p>"},{"location":"api/#utilsx.decorators.narrow_return","title":"<code>narrow_return(index)</code>","text":"<p>Makes a function returning a tuple return only the element at the given index.</p> <p>Implemented as a decorator factory.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the tuple element to return.</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[..., tuple[Any, ...]]], Callable[..., Any]]</code> <p>A decorator.</p> Source code in <code>src/utilsx/decorators.py</code> <pre><code>def narrow_return(\n    index: int,\n) -&gt; Callable[[Callable[..., tuple[Any, ...]]], Callable[..., Any]]:\n    \"\"\"Makes a function returning a tuple return only the element at the given index.\n\n    Implemented as a decorator factory.\n\n    Args:\n        index: The index of the tuple element to return.\n\n    Returns:\n        A decorator.\n    \"\"\"\n\n    def decorator(func: Callable[..., tuple[Any, ...]]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: ANN401\n            result = func(*args, **kwargs)\n            return result[index]\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#utilsx.dicts","title":"<code>dicts</code>","text":"<p>Utilities for working with dictionaries.</p>"},{"location":"api/#utilsx.dicts.multiply_dict_values","title":"<code>multiply_dict_values(dictionary, multiplier)</code>","text":"<p>Get a copy of the dictionary with values multiplied by scalar, preserving keys.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>Mapping[T, float]</code> <p>A dictionary to multiply values of.</p> required <code>multiplier</code> <code>float</code> <p>A scalar multiplier.</p> required <p>Returns:</p> Type Description <code>dict[T, float]</code> <p>A copy of the original dictionary with values multiplied by scalar.</p> Source code in <code>src/utilsx/dicts/_modification.py</code> <pre><code>def multiply_dict_values(dictionary: Mapping[T, float], multiplier: float) -&gt; dict[T, float]:\n    \"\"\"Get a copy of the dictionary with values multiplied by scalar, preserving keys.\n\n    Args:\n        dictionary: A dictionary to multiply values of.\n        multiplier: A scalar multiplier.\n\n    Returns:\n        A copy of the original dictionary with values multiplied by scalar.\n    \"\"\"\n    return {key: value * multiplier for key, value in dictionary.items()}\n</code></pre>"},{"location":"api/#utilsx.dicts.remove_items_with_zero_values","title":"<code>remove_items_with_zero_values(dictionary)</code>","text":"<p>Drop key-value pairs from a dictionary whose values are zero.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict[T, float]</code> <p>To be filtered to exclude key-value pairs with zero values.</p> required <p>Returns:</p> Type Description <code>dict[T, float]</code> <p>A subset of the original dictionary items, only pairs with non-zero values.</p> Source code in <code>src/utilsx/dicts/_filtering.py</code> <pre><code>def remove_items_with_zero_values(dictionary: dict[T, float]) -&gt; dict[T, float]:\n    \"\"\"Drop key-value pairs from a dictionary whose values are zero.\n\n    Args:\n        dictionary: To be filtered to exclude key-value pairs with zero values.\n\n    Returns:\n        A subset of the original dictionary items, only pairs with non-zero values.\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value}\n</code></pre>"},{"location":"api/#utilsx.dicts.rename_keys_in_nested_dict","title":"<code>rename_keys_in_nested_dict(dictionary, renaming)</code>","text":"<p>Replace all specified keys by other specified names in an arbitrarily deep dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict[str, Any]</code> <p>A dictionary of arbitrary depth.</p> required <code>renaming</code> <code>dict[str, str]</code> <p>A mapping from old to new key names.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Copy of the original dictionary with <code>old_key</code> renamed to <code>new_key</code></p> <code>dict[str, Any]</code> <p>at all levels of key depth.</p> Source code in <code>src/utilsx/dicts/_modification.py</code> <pre><code>def rename_keys_in_nested_dict(\n    dictionary: dict[str, Any], renaming: dict[str, str]\n) -&gt; dict[str, Any]:\n    \"\"\"Replace all specified keys by other specified names in an arbitrarily deep dictionary.\n\n    Args:\n        dictionary: A dictionary of arbitrary depth.\n        renaming: A mapping from old to new key names.\n\n    Returns:\n        Copy of the original dictionary with ``old_key`` renamed to ``new_key``\n        at all levels of key depth.\n    \"\"\"\n    # This ``isinstance`` check is required to leave non-dict structures as-is.\n    if isinstance(dictionary, dict):\n        return {\n            (renaming.get(key, key)): rename_keys_in_nested_dict(value, renaming)\n            for key, value in dictionary.items()\n        }\n    return dictionary\n</code></pre>"},{"location":"api/#utilsx.dicts.sort_by_value","title":"<code>sort_by_value(dictionary, reverse=False)</code>","text":"<p>Sort a dictionary with numeric values by those values.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict[T, NumberT]</code> <p>A dictionary to sort by value.</p> required <code>reverse</code> <code>bool</code> <p>False for ascending order, True for descending. Exactly matches the <code>reverse</code> argument of <code>sorted</code> Python function.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[T, NumberT]</code> <p>Same dictionary in terms of content, just sorted by value.</p> Source code in <code>src/utilsx/dicts/_sorting.py</code> <pre><code>def sort_by_value(dictionary: dict[T, NumberT], reverse: bool = False) -&gt; dict[T, NumberT]:\n    \"\"\"Sort a dictionary with numeric values by those values.\n\n    Args:\n        dictionary: A dictionary to sort by value.\n        reverse: False for ascending order, True for descending. Exactly matches the ``reverse``\n            argument of ``sorted`` Python function.\n\n    Returns:\n        Same dictionary in terms of content, just sorted by value.\n    \"\"\"\n    return dict(sorted(dictionary.items(), key=lambda item: item[1], reverse=reverse))\n</code></pre>"},{"location":"api/#utilsx.dicts.sum_dicts","title":"<code>sum_dicts(*dicts)</code>","text":"<p>Given dictionaries, return their summation: a union of keys and totals of values.</p> <p>Parameters:</p> Name Type Description Default <code>*dicts</code> <code>dict[T, float]</code> <p>To be added up together, any number.</p> <code>()</code> <p>Returns:</p> Type Description <code>dict[T, float]</code> <p>A combined dictionary with a union of keys and totals of values.</p> Source code in <code>src/utilsx/dicts/_combination.py</code> <pre><code>def sum_dicts(*dicts: dict[T, float]) -&gt; dict[T, float]:\n    \"\"\"Given dictionaries, return their summation: a union of keys and totals of values.\n\n    Args:\n        *dicts: To be added up together, any number.\n\n    Returns:\n        A combined dictionary with a union of keys and totals of values.\n    \"\"\"\n    output: dict[T, float] = defaultdict(float)\n    for dictionary in dicts:\n        for key, value in dictionary.items():\n            output[key] += value\n    return dict(output)\n</code></pre>"},{"location":"api/#utilsx.exceptions","title":"<code>exceptions</code>","text":"<p>Utilities for raising exceptions.</p>"},{"location":"api/#utilsx.exceptions.hint_if_extra_uninstalled","title":"<code>hint_if_extra_uninstalled(required_modules, extra_name, package_name)</code>","text":"<p>Check if an optional dependency group is installed, and hint if not, via <code>ImportError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>required_modules</code> <code>Iterable[str]</code> <p>Modules which need to be installed in venv for that dependency group.</p> required <code>extra_name</code> <code>str</code> <p>Name of an optional dependency group.</p> required <code>package_name</code> <code>str</code> <p>Name of the package which provides a given optional dependency group.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If any of the required modules are not installed.</p> Source code in <code>src/utilsx/exceptions.py</code> <pre><code>def hint_if_extra_uninstalled(\n    required_modules: Iterable[str],\n    extra_name: str,\n    package_name: str,\n) -&gt; None:\n    \"\"\"Check if an optional dependency group is installed, and hint if not, via ``ImportError``.\n\n    Args:\n        required_modules: Modules which need to be installed in venv for that dependency group.\n        extra_name: Name of an optional dependency group.\n        package_name: Name of the package which provides a given optional dependency group.\n\n    Raises:\n        ImportError: If any of the required modules are not installed.\n    \"\"\"\n    for module in required_modules:\n        try:\n            import_module(module)\n        except ImportError as e:\n            raise ImportError(\n                f\"Optional dependency group '{extra_name}' is required for this feature.\\n\"\n                f\"Add '{package_name}[{extra_name}]' to your requirements list\"\n                \" and install to virtual environment.\"\n            ) from e\n</code></pre>"},{"location":"api/#utilsx.exceptions.prohibit_negative_values","title":"<code>prohibit_negative_values(values, exception_class=ValueError, exception_msg='Negative values are prohibited')</code>","text":"<p>Raise an exception if an iterable of numbers has negative values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Iterable[float]</code> <p>To check for any negative member.</p> required <code>exception_class</code> <code>type[Exception]</code> <p>Exception class to raise if any member is negative, defaults to <code>ValueError</code>.</p> <code>ValueError</code> <code>exception_msg</code> <code>str</code> <p>A message to add to the raised exception.</p> <code>'Negative values are prohibited'</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>src/utilsx/exceptions.py</code> <pre><code>def prohibit_negative_values(\n    values: Iterable[float],\n    exception_class: type[Exception] = ValueError,\n    exception_msg: str = \"Negative values are prohibited\",\n) -&gt; None:\n    \"\"\"Raise an exception if an iterable of numbers has negative values.\n\n    Args:\n        values: To check for any negative member.\n        exception_class: Exception class to raise if any member is negative,\n            defaults to ``ValueError``.\n        exception_msg: A message to add to the raised exception.\n\n    Returns:\n        None.\n    \"\"\"\n    if any(value &lt; 0 for value in values):\n        raise exception_class(exception_msg)\n</code></pre>"},{"location":"api/#utilsx.exceptions.raise_key_error_with_suggestions","title":"<code>raise_key_error_with_suggestions(attempted_key, existing_keys, object_name='object', attribute_name='key')</code>","text":"<p>Raise a key error complemented with suggestions based on closest matches.</p> <p>Parameters:</p> Name Type Description Default <code>attempted_key</code> <code>str</code> <p>A key that was attempted to be found.</p> required <code>existing_keys</code> <code>Collection[str]</code> <p>Existing keys, among which an attempted key was not found.</p> required <code>object_name</code> <code>str</code> <p>Archetype of an object that was searched by key.</p> <code>'object'</code> <code>attribute_name</code> <code>str</code> <p>If this key represents an attribute with explicit name.</p> <code>'key'</code> <p>Returns:</p> Type Description <code>NoReturn</code> <p>Never returns anything.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Complemented with close matches, if any.</p> Notes <p>Inspired by dataset name hint implemented in Kedro: https://github.com/kedro-org/kedro</p> Source code in <code>src/utilsx/exceptions.py</code> <pre><code>def raise_key_error_with_suggestions(\n    attempted_key: str,\n    existing_keys: Collection[str],\n    object_name: str = \"object\",\n    attribute_name: str = \"key\",\n) -&gt; NoReturn:\n    \"\"\"Raise a key error complemented with suggestions based on closest matches.\n\n    Args:\n        attempted_key: A key that was attempted to be found.\n        existing_keys: Existing keys, among which an attempted key was not found.\n        object_name: Archetype of an object that was searched by key.\n        attribute_name: If this key represents an attribute with explicit name.\n\n    Returns:\n        Never returns anything.\n\n    Raises:\n        KeyError: Complemented with close matches, if any.\n\n    Notes:\n        Inspired by dataset name hint implemented in Kedro: https://github.com/kedro-org/kedro\n    \"\"\"\n    error_msg = f\"{object_name.capitalize()} with {attribute_name} {attempted_key} not found.\"\n    close_matches = get_close_matches(attempted_key, existing_keys)\n    if close_matches:\n        suggestions = \", \".join(close_matches)\n        error_msg += f\" Did you mean one of these instead: {suggestions}?\"\n    raise KeyError(error_msg)\n</code></pre>"},{"location":"api/#utilsx.functional","title":"<code>functional</code>","text":"<p>Utilities for functional programming.</p>"},{"location":"api/#utilsx.functional.identity","title":"<code>identity(x)</code>","text":"<p>An identity function: returns a single input unchanged.</p> Source code in <code>src/utilsx/functional.py</code> <pre><code>def identity(x: T) -&gt; T:\n    \"\"\"An identity function: returns a single input unchanged.\"\"\"\n    return x\n</code></pre>"},{"location":"api/#utilsx.math","title":"<code>math</code>","text":"<p>Utilities for mathematical operations.</p>"},{"location":"api/#utilsx.math.ceil_to_multiple","title":"<code>ceil_to_multiple(x, multiple)</code>","text":"<p>Ceil a number to the next multiple of another value.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Number to ceil.</p> required <code>multiple</code> <code>int</code> <p>Enforce the output to be a multiple of.</p> required <p>Returns:</p> Type Description <code>int</code> <p>X input ceiled to the next multiple of another value.</p> Source code in <code>src/utilsx/math/_rounding.py</code> <pre><code>def ceil_to_multiple(x: float, multiple: int) -&gt; int:\n    \"\"\"Ceil a number to the next multiple of another value.\n\n    Args:\n        x: Number to ceil.\n        multiple: Enforce the output to be a multiple of.\n\n    Returns:\n        X input ceiled to the next multiple of another value.\n    \"\"\"\n    return math.ceil(x / multiple) * multiple\n</code></pre>"},{"location":"api/#utilsx.math.check_values_add_up_to_one","title":"<code>check_values_add_up_to_one(values, mode='either')</code>","text":"<p>Check if values in a collection add up to 1 or 100.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Collection[float]</code> <p>Values to check.</p> required <code>mode</code> <code>Literal['fractions', 'percentages', 'either']</code> <p>\"fractions\" if they should add up to 1, \"percentages\" if they should add up to 100, \"either\" if either of this works.</p> <code>'either'</code> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean outcome of the check.</p> Source code in <code>src/utilsx/math/_collections.py</code> <pre><code>def check_values_add_up_to_one(\n    values: Collection[float],\n    mode: Literal[\"fractions\", \"percentages\", \"either\"] = \"either\",\n) -&gt; bool:\n    \"\"\"Check if values in a collection add up to 1 or 100.\n\n    Args:\n        values: Values to check.\n        mode: \"fractions\" if they should add up to 1, \"percentages\" if they should add up to 100,\n            \"either\" if either of this works.\n\n    Returns:\n        Boolean outcome of the check.\n    \"\"\"\n    match mode:\n        case \"fractions\":\n            valid_totals = frozenset((1,))\n        case \"percentages\":\n            valid_totals = frozenset((100,))\n        case \"either\":\n            valid_totals = frozenset((1, 100))\n        case _:\n            raise ValueError(f\"Unrecognized mode: {mode}\")\n\n    sum_of_values = sum(values)\n    return any(\n        math.isclose(sum_of_values, valid_total, rel_tol=0.001) for valid_total in valid_totals\n    )\n</code></pre>"},{"location":"api/#utilsx.math.convert_number_to_units","title":"<code>convert_number_to_units(number, units)</code>","text":"<p>Convert a number to thousands or millions.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>Number to convert.</p> required <code>units</code> <code>_TUnits</code> <p>Units to convert to.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A number converted to specified units.</p> Source code in <code>src/utilsx/math/_downscaling.py</code> <pre><code>def convert_number_to_units(number: float, units: _TUnits) -&gt; float:\n    \"\"\"Convert a number to thousands or millions.\n\n    Args:\n        number: Number to convert.\n        units: Units to convert to.\n\n    Returns:\n        A number converted to specified units.\n    \"\"\"\n    match units:\n        case \"thousand\":\n            denominator = THOUSAND\n        case \"million\":\n            denominator = MILLION\n        case _:\n            raise ValueError(f\"Unrecognized units: {units}\")\n\n    return number / denominator\n</code></pre>"},{"location":"api/#utilsx.math.double","title":"<code>double(x)</code>","text":"<p>Multiply a number by two: in other words, double it.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The number to multiply by two.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Result of multiplying this number by literal integer two.</p> Source code in <code>src/utilsx/math/_scalar_ops.py</code> <pre><code>def double(x: float) -&gt; float:\n    \"\"\"Multiply a number by two: in other words, double it.\n\n    Args:\n        x: The number to multiply by two.\n\n    Returns:\n        Result of multiplying this number by literal integer two.\n    \"\"\"\n    return x * 2\n</code></pre>"},{"location":"api/#utilsx.math.halve","title":"<code>halve(x)</code>","text":"<p>Divide a number by two: in other words, get its half.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The number to divide by two.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Result of dividing this number by literal integer two.</p> Source code in <code>src/utilsx/math/_scalar_ops.py</code> <pre><code>def halve(x: float) -&gt; float:\n    \"\"\"Divide a number by two: in other words, get its half.\n\n    Args:\n        x: The number to divide by two.\n\n    Returns:\n        Result of dividing this number by literal integer two.\n    \"\"\"\n    return x / 2\n</code></pre>"},{"location":"api/#utilsx.math.is_monotonically_growing","title":"<code>is_monotonically_growing(time_series, multiplier)</code>","text":"<p>Check whether a time series can be considered monotonically growing.</p> <p>To be called so, each next element should be at least <code>multiplier</code> times bigger than a previous one. Series of less than two elements are considered non-growing.</p> <p>Parameters:</p> Name Type Description Default <code>time_series</code> <code>Sequence[float]</code> <p>A sequence of numbers.</p> required <code>multiplier</code> <code>float</code> <p>How many times bigger each next element should be.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if monotonically growing, False otherwise.</p> Source code in <code>src/utilsx/math/_collections.py</code> <pre><code>def is_monotonically_growing(time_series: Sequence[float], multiplier: float) -&gt; bool:\n    \"\"\"Check whether a time series can be considered monotonically growing.\n\n    To be called so, each next element should be at least ``multiplier`` times bigger than\n    a previous one. Series of less than two elements are considered non-growing.\n\n    Args:\n        time_series: A sequence of numbers.\n        multiplier: How many times bigger each next element should be.\n\n    Returns:\n        True if monotonically growing, False otherwise.\n    \"\"\"\n    if len(time_series) &lt; 2:  # noqa: PLR2004\n        return False\n    return all(\n        time_series[i + 1] &gt; time_series[i] * multiplier for i in range(len(time_series) - 1)\n    )\n</code></pre>"},{"location":"api/#utilsx.math.normalize","title":"<code>normalize(values)</code>","text":"<p>Normalize a sequence of numbers to make them add up to one.</p> Source code in <code>src/utilsx/math/_collections.py</code> <pre><code>def normalize(values: Sequence[float]) -&gt; list[float]:\n    \"\"\"Normalize a sequence of numbers to make them add up to one.\"\"\"\n    return [value / sum(values) for value in values]\n</code></pre>"},{"location":"api/#utilsx.math.safe_divide","title":"<code>safe_divide(numerator, denominator, fallback=0)</code>","text":"<p>Divide one number by another, falling back on something in case of <code>ZeroDivisionError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>numerator</code> <code>float</code> <p>Number to divide.</p> required <code>denominator</code> <code>float</code> <p>Denominator to use.</p> required <code>fallback</code> <code>float</code> <p>Fallback value to use in case the denominator is zero, defaults to zero.</p> <code>0</code> Source code in <code>src/utilsx/math/_division.py</code> <pre><code>def safe_divide(numerator: float, denominator: float, fallback: float = 0) -&gt; float:\n    \"\"\"Divide one number by another, falling back on something in case of ``ZeroDivisionError``.\n\n    Args:\n        numerator: Number to divide.\n        denominator: Denominator to use.\n        fallback: Fallback value to use in case the denominator is zero, defaults to zero.\n    \"\"\"\n    return numerator / denominator if denominator != 0 else fallback\n</code></pre>"},{"location":"api/#utilsx.pandas","title":"<code>pandas</code>","text":"<p>Utilities for enhancing your Pandas workflows.</p>"},{"location":"api/#utilsx.pandas.count_na","title":"<code>count_na(df)</code>","text":"<p>Get the total number of missing values in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>To count missing values in.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of missing values.</p> Source code in <code>src/utilsx/pandas/_missing.py</code> <pre><code>def count_na(df: pd.DataFrame) -&gt; int:\n    \"\"\"Get the total number of missing values in a DataFrame.\n\n    Args:\n        df: To count missing values in.\n\n    Returns:\n        The number of missing values.\n    \"\"\"\n    return int(df.isna().sum().sum())\n</code></pre>"},{"location":"api/#utilsx.text","title":"<code>text</code>","text":"<p>Utilities for text transformations.</p>"},{"location":"api/#utilsx.text.add_suffix","title":"<code>add_suffix(base, suffix, separator='_')</code>","text":"<p>Add suffix to a base string using a separator.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str</code> <p>Base string to add a suffix to.</p> required <code>suffix</code> <code>str</code> <p>A suffix to add.</p> required <code>separator</code> <code>str</code> <p>A separator to insert between the base and suffix.</p> <code>'_'</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with suffix concatenated to the base on the right, with a separator in between.</p> <p>If the suffix is empty, returns just the base string, omitting the separator.</p> Source code in <code>src/utilsx/text.py</code> <pre><code>def add_suffix(base: str, suffix: str, separator: str = \"_\") -&gt; str:\n    \"\"\"Add suffix to a base string using a separator.\n\n    Args:\n        base: Base string to add a suffix to.\n        suffix: A suffix to add.\n        separator: A separator to insert between the base and suffix.\n\n    Returns:\n        A string with suffix concatenated to the base on the right, with a separator in between.\n\n    If the suffix is empty, returns just the base string, omitting the separator.\n    \"\"\"\n    return f\"{base}{separator}{suffix}\" if suffix else base\n</code></pre>"},{"location":"api/#utilsx.typevars","title":"<code>typevars</code>","text":"<p>A collection of type variables.</p>"},{"location":"collections/","title":"\ud83d\uddc4\ufe0f Collections","text":"<p>One-liners for operations you may commonly perform on collections.</p>"},{"location":"collections/#check_equal_length","title":"<code>check_equal_length</code>","text":"<p>Consider a scenario where you receive synchronized lists of product information - such as names, prices, and stock levels - and need to verify that the data aligns before further processing:</p> manual.py<pre><code># Raw product data\nproduct_names = [\"coffee\", \"cookie\", \"juice\"]\nproduct_prices = [3.5, 2.0]  # Missing price for \"juice\"\nproduct_stock = [120, 85, 40]\n\n# Manual length check\nif not (len(product_names) == len(product_prices) == len(product_stock)):\n    raise ValueError(\"Mismatched product data lengths\")\n</code></pre> <p>Use UtilsX to perform that in a cleaner way:</p> with_utilsx.py<pre><code>from utilsx import check_equal_length\n\n# Raw product data\nproduct_names = [\"coffee\", \"cookie\", \"juice\"]\nproduct_prices = [3.5, 2.0]\nproduct_stock = [120, 85, 40]\n\n# Clean, readable validation\nif not check_equal_length(product_names, product_prices, product_stock):\n    raise ValueError(\"Mismatched product data lengths\")\n</code></pre>"},{"location":"collections/#get_duplicates","title":"<code>get_duplicates</code>","text":"<p>Imagine importing product SKUs from multiple warehouse systems and needing to identify duplicates before merging the inventory:</p> manual.py<pre><code>from collections import Counter\n\n# Combined list of product SKUs\nskus = [\n    \"SKU123\", \"SKU456\", \"SKU789\",\n    \"SKU123\", \"SKU999\", \"SKU456\"\n]\n\n# Manual duplicate detection\nsku_counts = Counter(skus)\nduplicates = {sku for sku, count in sku_counts.items() if count &gt; 1}\n\nprint(duplicates)\n# {\"SKU123\", \"SKU456\"}\n</code></pre> <p>Use UtilsX to make that much cleaner:</p> with_utilsx.py<pre><code>from utilsx import get_duplicates\n\n# Combined list of product SKUs\nskus = [\n    \"SKU123\", \"SKU456\", \"SKU789\",\n    \"SKU123\", \"SKU999\", \"SKU456\"\n]\n\n# Identify duplicate SKUs\nduplicates = get_duplicates(skus)\n\nprint(duplicates)\n# {\"SKU123\", \"SKU456\"}\n</code></pre>"},{"location":"collections/#is_collection_of_equal_elements","title":"<code>is_collection_of_equal_elements</code>","text":"<p>Suppose you check a batch of sensor readings to ensure stability - you require all readings in a window to match before taking action:</p> manual.py<pre><code># Sensor readings over a time window\nreadings = [42, 42, 42, 42]\n\n# Manual check for uniformity\nfirst = readings[0]\nif not all(r == first for r in readings):\n    raise ValueError(\"Sensor values are unstable\")\n</code></pre> <p>Use UtilsX to express that logic nicer:</p> with_utilsx.py<pre><code>from utilsx import is_collection_of_equal_elements\n\n# Sensor readings over a time window\nreadings = [42, 42, 42, 42]\n\nif not is_collection_of_equal_elements(readings):\n    raise ValueError(\"Sensor values are unstable\")\n</code></pre>"},{"location":"constants/","title":"\ud83e\udea8 Constants","text":"<p>Common real-world constants for you to reuse across your project.</p>"},{"location":"constants/#numbers","title":"Numbers","text":"<p>Commonly used literal numbers:</p> <ul> <li><code>ONE</code></li> <li><code>TWO</code></li> <li><code>TEN</code></li> <li><code>HUNDRED</code></li> <li><code>THOUSAND</code></li> <li><code>MILLION</code></li> <li><code>BILLION</code></li> <li><code>TRILLION</code></li> </ul> <p>Besides helping avoid duplication of magic numbers in your code, using these constants protects from typos involving missing / extra <code>0</code> in magic numbers.</p> <p>Example:</p> bad_practice.py<pre><code>revenue = 2819920021\n\n# The number below has a missing zero - how long would it take for you to spot?\nrevenue_billions = revenue / 100000000\n</code></pre> <p>Do instead:</p> good_practice.py<pre><code>from utilsx import BILLION\n\nrevenue = 2819920021\nrevenue_billions = revenue / BILLION\n</code></pre> <p>You can simplify conversion to thousands or millions even further</p> <p>Check out <code>convert_number_to_units</code> utility from math part of UtilsX for a shorthand function.</p> <p>The built-in <code>math</code> module provides constants like <code>pi</code> and <code>e</code></p> <p>See full list here. UtilsX does not re-define them, and encourages you to import them from <code>math</code>.</p>"},{"location":"constants/#physics","title":"Physics","text":"<p>UtilsX provides a few constants representing common mass and volume ratios:</p> <ul> <li><code>GAL_TO_LITER</code> and <code>LITER_TO_GAL</code></li> <li><code>GAL_TO_OZ</code> and <code>OZ_TO_GAL</code></li> <li><code>LBS_TO_KG</code> and <code>KG_TO_LBS</code></li> </ul> <p>Like numeric constraints, this set fights against duplicated magic numbers in codebases.</p> <p>Moreover, inconsistency here directly makes calculations imprecise:</p> bad_practice.py<pre><code># Work of one developer\nproduction_kg = 500\nproduction_lbs = production_kg * 2.205\n\n# Work of another developer\nconsumption_lbs = 1000\nconsumption_kg = consumption_lbs * (1 / 2.20462)\n</code></pre> <p>A conversion ratio shouldn't appear as <code>2.205</code> in one part of the codebase, and <code>2.20462</code> in another.</p> <p>Do instead:</p> good_practice.py<pre><code>from utilsx import KG_TO_LBS, LBS_TO_KG\n\n# Work of one developer\nproduction_kg = 500\nproduction_lbs = production_kg * KG_TO_LBS\n\n# Work of another developer\nconsumption_lbs = 1000\nconsumption_kg = consumption_lbs * LBS_TO_KG\n</code></pre> <p>You may also use SciPy's <code>constants</code> module</p> <p>For deep scientific projects, likely it would be more suitable.</p> <p>UtilsX, however:</p> <ul> <li>Is more lightweight: does not bring whole SciPy (and NumPy as its transitive dependency) to your venv.</li> <li>Uses more explicit names: e.g., <code>KG_TO_LBS</code> vs <code>pound</code> in SciPy.</li> <li>Defines constants missing in SciPy: like <code>GAL_TO_OZ</code>, while SciPy only provides gallon-to-cubic-meter ratios.</li> </ul> <p>For unit conversion ratios, UtilsX follows the following naming convention:</p> <p>Constants follow the <code>A_TO_B</code> naming convention, such that a value in units <code>A</code> multiplied by <code>A_TO_B</code> becomes the same amount in units <code>B</code>.</p> <p>Why this convention?</p> <p>In early versions, for instance, <code>KG_TO_LBS</code> was called <code>LBS_IN_KG</code>.</p> <p>That name is ambiguous because can be interpreted both as:</p> <ul> <li>How many lbs is there in 1 kg? (~2.2)</li> <li>How many kg would it take to represent 1 lbs? (~0.45)</li> </ul> <p>To avoid that, UtilsX follows the <code>_TO_</code> convention, and declares that all such constants should be used as multipliers.</p>"},{"location":"constants/#time","title":"Time","text":"<p>Constants like:</p> <ul> <li><code>SECONDS_IN_MINUTE</code></li> <li><code>MINUTES_IN_DAY</code></li> <li><code>HOURS_IN_YEAR</code></li> </ul> <p>And tens more of the same nature, following the naming semantics <code>A_IN_B</code>. Read them as \"How many units of <code>A</code> make up one unit of <code>B</code>\".</p> <p>While the numeric constants help prevent typos, and physics ones help achieve precision and consistency, the time improves readability more than anything else.</p> <p>Example:</p> bad_practice.py<pre><code># What does this conversion do: hours -&gt; minutes or minutes -&gt; seconds?\ndata[\"revenue\"] /= 60\n</code></pre> <p>Do instead:</p> good_practice.py<pre><code>from utilsx import MINUTES_IN_HOUR\n\ndata[\"revenue\"] /= MINUTES_IN_HOUR\n</code></pre>"},{"location":"decorators/","title":"\ud83c\udfa8 Decorators","text":"<p>Decorators to assist you in adjusting functions' behavior.</p>"},{"location":"decorators/#narrow_return","title":"<code>narrow_return</code>","text":"<p>This decorator modifies a function which returns multiple elements to only return one, at a specified index of the returned tuple.</p> <p>Consider <code>plot_series</code> function from the <code>sktime</code> library, which returns two elements:</p> <ol> <li>A <code>matplotlib</code> figure: <code>plt.Figure</code></li> <li>An axis object: <code>plt.Axis</code></li> </ol> original_workflow.py<pre><code>from sktime.utils.plotting import plot_series\nfrom sktime.datasets import load_airline\n\ny = load_airline()\nfig, ax = plot_series(y)\n</code></pre> <p>Oftentimes you only care about the former.</p> <p>You can adjust this function to only return a <code>fig</code>:</p> narrow_return.py<pre><code>from sktime.utils.plotting import plot_series\nfrom sktime.datasets import load_airline\nfrom utilsx import narrow_return\n\nplot_series_to_figure = narrow_return(0)(plot_series)\n\ny = load_airline()\nfig = plot_series_to_figure(y)\n</code></pre> <p>This can help while working with orchestration frameworks like Kedro, where unused elements in the returned tuple clutter the directed acyclic graph.</p>"},{"location":"dictionaries/","title":"\ud83d\udccb Dictionaries","text":"<p>One-liners for operations you may commonly perform on dictionaries.</p>"},{"location":"dictionaries/#combination","title":"Combination","text":""},{"location":"dictionaries/#sum_dicts","title":"<code>sum_dicts</code>","text":"<p>Consider an example with two coffee shop locations, each reporting sales as a dictionary, with the goal of producing a dictionary of total sales:</p> before.py<pre><code>from collections import defaultdict\n\n# Sales from two locations\nnorth_sales = {\"coffee\": 120, \"cookie\": 5, \"juice\": 40}\nsouth_sales = {\"coffee\": 80, \"cookie\": 45, \"banana\": 10}\n\n# Manual summation using defaultdict\ncombined_sales = defaultdict(int)\nfor location_sales in (north_sales, south_sales):\n    for product, quantity in location_sales.items():\n        combined_sales[product] += quantity\n\nprint(combined_sales)\n# {\"coffee\": 200, \"cookie\": 50, \"juice\": 40, \"banana\": 10}\n</code></pre> <p>Why avoid this approach?</p> <p>Note that the dictionary summation logic takes more than half of the code: 5 lines out of 8. But nothing in it relates specifically to business logic - combining sales.</p> <p>Use UtilsX to drastically simplify the preceding code:</p> after.py<pre><code>from utilsx import sum_dicts\n\n# Sales from two locations\nnorth_sales = {\"coffee\": 120, \"cookie\": 5, \"juice\": 40}\nsouth_sales = {\"coffee\": 80, \"cookie\": 45, \"banana\": 10}\n\n# Summation using UtilsX function\ncombined_sales = sum_dicts(north_sales, south_sales)\n\nprint(combined_sales)\n# {\"coffee\": 200, \"cookie\": 50, \"juice\": 40, \"banana\": 10}\n</code></pre>"},{"location":"dictionaries/#filtering","title":"Filtering","text":""},{"location":"dictionaries/#remove_items_with_zero_values","title":"<code>remove_items_with_zero_values</code>","text":"<p>Consider a case where a coffee shop tracks product sales, but some items haven\u2019t sold at all. The sales report includes all items, even those with zero sales - which clutters the output and may cause confusion in downstream reporting.</p> before.py<pre><code># Sales including items with zero quantity\nsales_report = {\n    \"coffee\": 200,\n    \"cookie\": 0,\n    \"juice\": 40,\n    \"banana\": 0,\n    \"sandwich\": 25,\n}\n\n# Filtering using a dictionary comprehension\ncleaned_report = {item: qty for item, qty in sales_report.items() if qty}\n\nprint(cleaned_report)\n# {\"coffee\": 200, \"juice\": 40, \"sandwich\": 25}\n</code></pre> <p>Why avoid this approach?</p> <p>The filtering logic still mixes with business logic \u2014 it obscures the intent to simply \"clean up the report.\" Repeating this pattern across different places increases maintenance cost.</p> <p>Use UtilsX to cleanly filter the sales report:</p> after.py<pre><code>from utilsx import remove_items_with_zero_values\n\n# Sales including items with zero quantity\nsales_report = {\n    \"coffee\": 200,\n    \"cookie\": 0,\n    \"juice\": 40,\n    \"banana\": 0,\n    \"sandwich\": 25,\n}\n\n# Remove zero-value entries using UtilsX\ncleaned_report = remove_items_with_zero_values(sales_report)\n\nprint(cleaned_report)\n# {\"coffee\": 200, \"juice\": 40, \"sandwich\": 25}\n</code></pre>"},{"location":"dictionaries/#modification","title":"Modification","text":""},{"location":"dictionaries/#multiply_dict_values","title":"<code>multiply_dict_values</code>","text":"<p>Consider a scenario where an inventory system stores product weights in kilograms, but a downstream system - for example, a shipping provider - requires the same data in pounds.</p> before.py<pre><code># Product weights in kilograms\nproduct_weights_kg = {\n    \"coffee_beans\": 12.5,\n    \"cookies\": 3.0,\n    \"juice_boxes\": 8.75,\n}\n\n# Manual conversion to pounds\nproduct_weights_lb = {\n    weight_kg * 2.20462\n    for item, weight_kg in product_weights_kg.items()\n}\n\nprint(product_weights_lb)\n# {\"coffee_beans\": 27.558, \"cookies\": 6.614, \"juice_boxes\": 19.290}\n</code></pre> <p>Why avoid this approach?</p> <p>The logic for applying a constant multiplier gets mixed in with the business need \u2014 unit conversion. It adds noise and reduces reuse in other places requiring the same transformation.</p> <p>Another issue with the code above is a hard-coded <code>2.20462</code> ratio.</p> <p>Use UtilsX to cleanly express unit conversion:</p> after.py<pre><code>from utilsx import KG_TO_LBS, multiply_dict_values\n\n# Product weights in kilograms\nproduct_weights_kg = {\n    \"coffee_beans\": 12.5,\n    \"cookies\": 3.0,\n    \"juice_boxes\": 8.75,\n}\n\n# Convert to pounds\nproduct_weights_lb = multiply_dict_values(product_weights_kg, KG_TO_LBS)\n\nprint(product_weights_lb)\n# {\"coffee_beans\": 27.558, \"cookies\": 6.614, \"juice_boxes\": 19.290}\n</code></pre>"},{"location":"dictionaries/#rename_keys_in_nested_dict","title":"<code>rename_keys_in_nested_dict</code>","text":"<p>Consider a scenario where you\u2019re processing a legacy configuration file in a deeply nested dictionary format. Teams authored this file over many years, and some keys have outdated or inconsistent names.</p> <p>You want to rename <code>\"usr\"</code> and <code>\"pwd\"</code> key names across all levels of nesting to <code>\"user\"</code> and <code>\"password\"</code> respectively.</p> config_example.py<pre><code>legacy_config = {\n    \"db_config\": {\n        \"usr\": \"admin\",\n        \"pwd\": \"secret\",\n        \"host\": \"localhost\",\n        \"port\": 5432,\n    },\n    \"log_settings\": {\n        \"lvl\": \"INFO\",\n        \"dir\": \"/var/log/app\",\n        \"otel_credentials\": {\n            \"usr\": \"otel_admin\",\n            \"pwd\": \"otel_password\",\n        },\n    },\n}\n</code></pre> <p>Use UtilsX to rename those keys at all levels in one line:</p> utilsx_workflow.py<pre><code>from utilsx import rename_keys_in_nested_dict\n\nlegacy_config = {...}\n\nrelevant_config = rename_keys_in_nested_dict(\n    dictionary=legacy_config,\n    renaming={\n        \"usr\": \"user\",\n        \"pwd\": \"password\",\n    },\n)\n\nprint(relevant_config)\n# {\n#     \"db_config\": {\n#         \"user\": \"admin\",\n#         \"password\": \"secret\",\n#         \"host\": \"localhost\",\n#         \"port\": 5432,\n#     },\n#     \"log_settings\": {\n#         \"lvl\": \"INFO\",\n#         \"dir\": \"/var/log/app\",\n#         \"otel_credentials\": {\n#             \"user\": \"otel_admin\",\n#             \"password\": \"otel_password\",\n#         },\n#     },\n# }\n</code></pre>"},{"location":"dictionaries/#sorting","title":"Sorting","text":""},{"location":"dictionaries/#sort_by_value","title":"<code>sort_by_value</code>","text":"<p>You can use Python's built-in <code>sorted</code> function to sort a dictionary by value, but that requires specifying a lambda function.</p> <p>Because this task occurs frequently, UtilsX offers a shorthand to simplify it:</p> sort_by_value.py<pre><code>from utilsx import sort_by_value\n\nproduct_revenue = {\n    \"coffee\": 2400,\n    \"juice\": 1200,\n    \"cookie\": 800,\n    \"banana\": 1600,\n}\n\n# Sort products by revenue, highest first\ntop_selling = sort_by_value(product_revenue, reverse=True)\n\nprint(top_selling)\n# {\"coffee\": 2400, \"banana\": 1600, \"juice\": 1200, \"cookie\": 800}\n</code></pre>"},{"location":"exceptions/","title":"\u26d4 Exceptions","text":"<p>Utilities to help enrich exception messages.</p>"},{"location":"exceptions/#hint_if_extra_uninstalled","title":"<code>hint_if_extra_uninstalled</code>","text":"<p>When developing a package with optional extras, a good practice involves guiding users on how to install the required dependencies if they attempt to import a feature without the corresponding extra.</p> <p>Check out this example from UtilsX itself, particularly the <code>utils.pandas</code> module:</p> <pre><code>\"\"\"Utilities for enhancing your Pandas workflows.\"\"\"\n\nfrom utilsx.exceptions import hint_if_extra_uninstalled as _hint_if_extra_uninstalled\n\n_hint_if_extra_uninstalled(\n    required_modules=frozenset((\"pandas\",)),\n    extra_name=\"pandas\",\n    package_name=\"utilsx\",\n)\n\n# This import should be after the dependency group check logic.\nfrom ._missing import *  # noqa: E402\n</code></pre> <p>Note:</p> <ol> <li>The import statement renames the helper function to a private identifier <code>_hint_if_extra_uninstalled</code> so that it doesn't appear in IDE auto-complete for users of <code>utilsx.pandas</code>.</li> <li>Wildcard imports from submodules follow the hint function ensuring the optional <code>utilsx[pandas]</code> extra gets validated before exposing public symbols.</li> </ol>"},{"location":"exceptions/#prohibit_negative_values","title":"<code>prohibit_negative_values</code>","text":"<p>Suppose you process a list of daily sales amounts that must never contain negative values, as they represent revenue:</p> manual.py<pre><code># Daily sales data\nsales = [1200.0, 1500.5, -300.0, 1100.0]\n\n# Manual check for negatives\nif any(sale &lt; 0 for sale in sales):\n    raise ValueError(\"Sales data contains negative values\")\n</code></pre> <p>This check remains straightforward but forces you to repeat the same pattern wherever you enforce non-negativity, cluttering your code.</p> <p>Use UtilsX to make this validation clear and reusable:</p> with_utilsx.py<pre><code>from utilsx import prohibit_negative_values\n\n# Daily sales data\nsales = [1200.0, 1500.5, -300.0, 1100.0]\n\nprohibit_negative_values(sales)\n# ValueError: Negative values are prohibited\n</code></pre> <p>With <code>prohibit_negative_values</code>, you express your intent directly, improving readability and reducing boilerplate in data validation steps.</p> <p>By default, it raises <code>ValueError(\"Negative values are prohibited\")</code>, but both exception class and the message are configurable through function arguments.</p>"},{"location":"exceptions/#raise_key_error_with_suggestions","title":"<code>raise_key_error_with_suggestions</code>","text":"<p>Suppose you look up car models in a catalog and want to provide helpful feedback when a user queries a missing model, suggesting alternatives to reduce frustration:</p> plain_key_error.py<pre><code>car_catalog = {\n    \"Toyota\": [\"Camry\", \"Corolla\", \"Prius\"],\n    \"Honda\": [\"Civic\", \"Accord\", \"CR-V\"],\n    \"Ford\": [\"F-150\", \"Mustang\", \"Explorer\"],\n}\n\ndef get_car_models(brand):\n    if brand not in car_catalog:\n        raise KeyError(f\"Car brand {brand} not found.\")\n    return car_catalog[brand]\n\nget_car_models(\"Toyta\")\n# KeyError: Car brand Toyta not found.\n</code></pre> <p>The error message provides no guidance or suggestions, leaving users to guess correct brand names and slowing down debugging or user input.</p> <p>Use UtilsX to enhance your error reporting:</p> key_error_with_suggestion.py<pre><code>from utilsx import raise_key_error_with_suggestions\n\ncar_catalog = {\n    \"Toyota\": [\"Camry\", \"Corolla\", \"Prius\"],\n    \"Honda\": [\"Civic\", \"Accord\", \"CR-V\"],\n    \"Ford\": [\"F-150\", \"Mustang\", \"Explorer\"],\n}\n\ndef get_car_models(brand):\n    if brand not in car_catalog:\n        raise_key_error_with_suggestions(\n            attempted_key=brand,\n            existing_keys=car_catalog.keys(),\n            object_name=\"car brand\",\n            attribute_name=\"name\",\n        )\n    return car_catalog[brand]\n\nget_car_models(\"Toyta\")\n# KeyError: Car brand with name Toyta not found.\n# Did you mean one of these instead: Toyota, Honda?\n</code></pre> <p><code>raise_key_error_with_suggestions</code> improves user experience by offering actionable hints, helping users correct typos or misunderstandings quickly.</p>"},{"location":"functional/","title":"\u27b0 Functional","text":"<p>Utilities for functional programming.</p>"},{"location":"functional/#identity","title":"<code>identity</code>","text":"<p>Takes a single object and returns it right away.</p> <p>Other open source libraries provide it, but current implementation stands out thanks to proper typing via <code>TypeVar</code>.</p> <p>It helps an IDE to automatically highlight errors like this:</p> highlighted_error.py<pre><code>from utilsx.functional import identity\n\nnumber = identity(3)\ntext = identity(\"apple\")\n\n# IDE warns about this guaranteed TypeError\ncombo = number + text\n</code></pre>"},{"location":"math/","title":"\ud83e\uddee Math","text":"<p>Mathematical utilities that come handy in analytics pieces of your code.</p>"},{"location":"math/#collections","title":"Collections","text":""},{"location":"math/#check_values_add_up_to_one","title":"<code>check_values_add_up_to_one</code>","text":"<p>Useful in data validation to assure that values in a collection add up to 1 or 100.</p> <p>Imagine a cooking recipe defined as proportions:</p> recipe.py<pre><code>from utilsx import check_values_add_up_to_one\n\nrecipe = {\n    \"water\": 0.5,\n    \"sauce\": 0.1,\n    \"potatoes\": 0.25,\n    \"fish\": 0.15,\n}\n\ncheck_values_add_up_to_one(recipe.values())\n# True\n</code></pre> <p>By default, it returns <code>True</code> if values add up either to 1 or 100. You can control this behavior using the <code>mode</code> argument.</p>"},{"location":"math/#is_monotonically_growing","title":"<code>is_monotonically_growing</code>","text":"<p>Suppose you check memory usage of a long-running data processing job. You expect fluctuations, but consistent exponential growth across intervals likely signals a memory leak:</p> before.py<pre><code># Memory usage sampled over time (in MB)\nmemory_readings = [200, 210, 225, 250, 290, 350]\n\n# Manual leak detection logic\nmultiplier = 1.05  # Acceptable growth rate per interval\nfor i in range(len(memory_readings) - 1):\n    if memory_readings[i + 1] &lt;= memory_readings[i] * multiplier:\n        break\nelse:\n    raise RuntimeError(\"Potential memory leak: sustained growth detected\")\n</code></pre> <p>Manual leak detection logic repeats across systems and lacks clarity. The intent \"memory grows too steadily\" gets buried in low-level detail.</p> <p>Use UtilsX to make it more concise:</p> after.py<pre><code>from utilsx import is_monotonically_growing\n\n# Memory usage sampled over time (in MB)\nmemory_readings = [200, 210, 225, 250, 290, 350]\n\n# Flag if memory grows steadily over time\nif is_monotonically_growing(memory_readings, multiplier=1.05):\n    raise RuntimeError(\"Potential memory leak: sustained growth detected\")\n</code></pre> <p><code>is_monotonically_growing</code> captures the intent behind the check - guarding against unchecked growth - without relying on verbose loop logic. The function works well in monitoring scripts, system health checks, and automated alerting pipelines.</p>"},{"location":"math/#normalize","title":"<code>normalize</code>","text":"<p>Helps you scale a sequence of numbers to add up to one, while keeping original relations.</p> portfolio.py<pre><code>from utilsx import normalize\n\nholdings_usd = [300, 50, 120]\n\nholdings_proportions = normalize(holdings_usd)\nprint(holdings_proportions)\n# [0.6383, 0.1064, 0.2553]\n</code></pre>"},{"location":"math/#division","title":"Division","text":""},{"location":"math/#safe_divide","title":"<code>safe_divide</code>","text":"<p>Helps you avoid writing a <code>try</code> / <code>except ZeroDivisionError</code> clause when the divisor might equal zero.</p> return_on_equity.py<pre><code>from utilsx import safe_divide\n\nprofit = 12\nequity = 0\n\nroe = safe_divide(profit, equity)\nprint(f\"Return on equity: {roe:.0%}\")\n# Return on equity: 0%\n</code></pre>"},{"location":"math/#downscaling","title":"Downscaling","text":""},{"location":"math/#convert_number_to_units","title":"<code>convert_number_to_units</code>","text":"<p>Convert numbers to thousands / millions.</p> downscaling.py<pre><code>from utilsx import convert_number_to_units\n\nrevenue_usd = 132890200\nrevenue_musd = convert_number_to_units(revenue_usd, \"million\")\nprint(revenue_musd)\n# 132.8902\n</code></pre>"},{"location":"math/#rounding","title":"Rounding","text":""},{"location":"math/#ceil_to_multiple","title":"<code>ceil_to_multiple</code>","text":"<p>Like the built-in <code>math.ceil</code>, but rounds up to a specified multiple.</p> <p>Consider a shop with changes only in increments of $5:</p> ceiling_to_multiple.py<pre><code>from utilsx import ceil_to_multiple\n\nitems_cost = 72\nbill_amount = ceil_to_multiple(items_cost, 5)\n\nprint(bill_amount)\n# 75\n</code></pre>"},{"location":"math/#scalar-operations","title":"Scalar operations","text":""},{"location":"math/#double","title":"<code>double</code>","text":"<p>This function just doubles a number:</p> doubling.py<pre><code>from utilsx import double\n\nstandard_price = 100\nvip_price = double(standard_price)\n\nprint(vip_price)\n# 200\n</code></pre> <p>This performs the same operation as <code>* 2</code>.</p> <p>This helps to:</p> <ul> <li>Emphasize that the logic doubles the value,   rather than multiplying by a number that currently equals 2 but might change.</li> <li>Help avoid typos and lint errors caused by a magic number.</li> </ul>"},{"location":"math/#halve","title":"<code>halve</code>","text":"<p>The inverse of <code>double</code>.</p>"},{"location":"pandas/","title":"\ud83d\udc3b\u200d\u2744\ufe0f Pandas","text":"<p>Utilities for working with Pandas.</p>"},{"location":"pandas/#count_na","title":"<code>count_na</code>","text":"<p>Pandas DataFrame lacks a built-in property for counting total missing values across the entire dataframe, so this utility function provides that capability.</p> <pre><code>import pandas as pd\nfrom utilsx.pandas import count_na\n\ndf = pd.DataFrame(...)\nif count_na(df):\n    print(\"Dataframe has missing values!\")\n</code></pre> <p>This technique helps during unit tests of data cleaning functions, especially when confirming that the logic retains certain missing values.</p>"},{"location":"text/","title":"\ud83d\udcdd Text","text":"<p>String utilities missing in the standard library, or complementing it nicely.</p>"},{"location":"text/#add_suffix","title":"<code>add_suffix</code>","text":"<p>Imagine naming files for multiple versions of a report with a consistent way to append version identifiers:</p> manual.py<pre><code>report_name = \"Q1_financials\"\nversion = \"v2\"\n\nif version:\n    final_name = report_name + \"_\" + version\nelse:\n    final_name = report_name\n\nprint(final_name)\n# \"Q1_financials_v2\"\n</code></pre> <p>This logic appears simple, but repetition across the codebase leads to inconsistency, unnecessary branching, and cluttered string operations.</p> <p>Use UtilsX to streamline suffix construction:</p> with_utilsx.py<pre><code>from utilsx import add_suffix\n\nreport_name = \"Q1_financials\"\nversion = \"v2\"\n\nfinal_name = add_suffix(report_name, version)\n\nprint(final_name)\n# \"Q1_financials_v2\"\n</code></pre> <p>You can also change the separator:</p> <pre><code>add_suffix(\"client\", \"archived\", separator=\"-\")\n# \"client-archived\"\n</code></pre>"},{"location":"typevars/","title":"\ud83c\uddf9 Type variables","text":"<p>A collection of reusable type variables for your own type-safe generic utilities.</p> <p>These aliases help clarify intent in your function signatures and ensure consistent typing behavior across your codebase.</p>"},{"location":"typevars/#t","title":"<code>T</code>","text":"<p>A generic, unconstrained type variable. Use this when the input and output match in type, while allowing any concrete type as input.</p> t_var.py<pre><code>from typing import Iterable\n\nfrom utilsx.types import T\n\n\ndef first_item(items: Iterable[T]) -&gt; T:\n    for item in items:\n        return item\n    raise ValueError(\"Empty iterable\")\n\nfirst_item([\"a\", \"b\", \"c\"])  # str\nfirst_item([1, 2, 3])        # int\n</code></pre> <p>This ensures the return type matches the input collection\u2019s element type.</p>"},{"location":"typevars/#numbert","title":"<code>NumberT</code>","text":"<p>Useful in contexts like <code>T</code>, but when you want to limit the type to <code>float</code> or its parents.</p> number_t.py<pre><code>from typing import Iterable\n\nfrom utilsx.types import NumberT\n\n\ndef average(values: Iterable[NumberT]) -&gt; float:\n    values = list(values)\n    if not values:\n        raise ValueError(\"Cannot compute average of empty list\")\n    return sum(values) / len(values)\n\naverage([10, 20, 30])    # OK: list of ints\naverage([1.5, 2.5, 3.0]) # OK: list of floats\naverage([\"a\", \"b\"])      # \u274c type checker will flag this\n</code></pre>"}]}